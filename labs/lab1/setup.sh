#!/usr/bin/env bash
set -euo pipefail

log() { echo "[$(date +'%F %T')] $*" >&2; }

require_root() {
  if [[ "${EUID}" -ne 0 ]]; then
    echo "Please run as root: sudo $0" >&2
    exit 1
  fi
}

require_root

# -------------------------------------------------------------------
# 0) Dependencies + repo layout normalization
# -------------------------------------------------------------------
log "Checking updates & installing dependencies..."
export DEBIAN_FRONTEND=noninteractive
apt-get update -y
apt-get install -y net-tools sshpass python3 python3-pip expect networkd-dispatcher

# Normalize folder name (if you unzipped as uproot-labs-lab1 or similar)
# We rename the FIRST match we find into /home/user/uproot if needed.
BASE_HOME="/home/user"
cd "${BASE_HOME}"

if [[ ! -d "${BASE_HOME}/uproot" ]]; then
  shopt -s nullglob
  matches=( "${BASE_HOME}"/uproot-labs-* )
  shopt -u nullglob
  if (( ${#matches[@]} > 0 )); then
    log "Renaming ${matches[0]} -> ${BASE_HOME}/uproot"
    mv "${matches[0]}" "${BASE_HOME}/uproot"
  fi
fi

# Copy golden env -> active env (lab root)
if [[ -f "${BASE_HOME}/uproot/labs/lab1/.env.golden" ]]; then
  log "Copying .env.golden -> .env"
  cp -f "${BASE_HOME}/uproot/labs/lab1/.env.golden" "${BASE_HOME}/uproot/labs/lab1/.env"
fi

# -------------------------------------------------------------------
# 1) Persistent routing off ens4 (DHCP) using netplan + networkd-dispatcher
# -------------------------------------------------------------------
log "Configuring ens4 as DHCP + persistent dynamic routes (gateway learned via DHCP)..."

IFACE="ens4"
ENS4_SNIPPET="/etc/netplan/99-${IFACE}-dhcp.yaml"

ROUTES_TO_ADD=(
  "1.1.1.0/30"
  "2.2.2.0/30"
  "3.3.3.0/30"
  "192.168.0.0/16"
)

log "Writing netplan snippet: ${ENS4_SNIPPET}"
if [[ -f "${ENS4_SNIPPET}" ]]; then
  cp -a "${ENS4_SNIPPET}" "${ENS4_SNIPPET}.bak.$(date +%s)"
fi

cat > "${ENS4_SNIPPET}" <<EOF
# Generated by setup.sh (Uproot Lab1)
network:
  version: 2
  ethernets:
    ${IFACE}:
      dhcp4: true
      dhcp4-overrides:
        route-metric: 200
EOF

log "Applying netplan..."
netplan apply

# networkd-dispatcher hook: runs whenever the interface becomes "routable"
HOOK_DIR="/etc/networkd-dispatcher/routable.d"
HOOK_PATH="${HOOK_DIR}/50-${IFACE}-routes"

mkdir -p "${HOOK_DIR}"

cat > "${HOOK_PATH}" <<'EOF'
#!/usr/bin/env bash
set -euo pipefail

TARGET_IFACE="ens4"

ROUTES_TO_ADD=(
  "1.1.1.0/30"
  "2.2.2.0/30"
  "3.3.3.0/30"
  "192.168.0.0/16"
)

# networkd-dispatcher sets IFACE and STATE in the environment
[[ "${IFACE:-}" == "${TARGET_IFACE}" ]] || exit 0

GW="$(ip route show default dev "$TARGET_IFACE" 2>/dev/null | awk '$1=="default"{print $3; exit}')"
if [[ -z "$GW" ]]; then
  logger -t ens4-routes "No default gateway yet on ${TARGET_IFACE}; skipping route install"
  exit 0
fi

logger -t ens4-routes "Installing routes via ${GW} on ${TARGET_IFACE}"
for net in "${ROUTES_TO_ADD[@]}"; do
  ip route replace "$net" via "$GW" dev "$TARGET_IFACE"
done
EOF

chmod +x "${HOOK_PATH}"
systemctl enable --now networkd-dispatcher >/dev/null 2>&1 || true
systemctl restart networkd-dispatcher

log "Current routes (post netplan/apply; dynamic routes may appear once DHCP is up):"
ip route | sed 's/^/  /'

# -------------------------------------------------------------------
# 2) Enable REST API on pfSense (upload pkg + install via console menu)
# -------------------------------------------------------------------
log "Setting up REST API package on pfSense Firewalls (Branch + App)"

ENV_FILE="${BASE_HOME}/uproot/labs/lab1/.env"
USER_PFS="root"
PKG_FILE="pfSense-2.8.1-pkg-RESTAPI.pkg"

env_upsert() {
  local key="$1"
  local value="$2"

  local escaped
  escaped="$(printf '%s' "$value" | sed 's/\\/\\\\/g; s/"/\\"/g')"

  if [[ -f "$ENV_FILE" ]] && grep -qE "^${key}=" "$ENV_FILE"; then
    sed -i "s|^${key}=.*|${key}=\"${escaped}\"|g" "$ENV_FILE"
  else
    printf '\n%s="%s"\n' "$key" "$escaped" >> "$ENV_FILE"
  fi
}

read -rp "Branch pfSense MGMT IP [1.1.1.2]: " BRANCH_FW
BRANCH_FW="${BRANCH_FW:-1.1.1.2}"
read -srp "Branch pfSense password: " BRANCHPASS
echo

read -rp "App pfSense MGMT IP [3.3.3.2]: " APP_FW
APP_FW="${APP_FW:-3.3.3.2}"
read -srp "App pfSense password: " APPPASS
echo

env_upsert "BRANCH_FW_MGMT_IP" "$BRANCH_FW"
env_upsert "BRANCH_FW_PASSWORD" "$BRANCHPASS"
env_upsert "APP_FW_MGMT_IP" "$APP_FW"
env_upsert "APP_FW_PASSWORD" "$APPPASS"

# shellcheck disable=SC1090
if [[ -f "$ENV_FILE" ]]; then
  set -a
  source "$ENV_FILE"
  set +a
else
  log "ERROR: $ENV_FILE not found"
  exit 1
fi

upload_pkg() {
  local host="$1"
  local pass="$2"

  log "Uploading ${PKG_FILE} to ${host}..."
  sshpass -p "$pass" sftp \
    -o StrictHostKeyChecking=no \
    -o UserKnownHostsFile=/dev/null \
    "${USER_PFS}@${host}" <<EOF
put /home/user/uproot/opt/pfsense/${PKG_FILE} /root/${PKG_FILE}
bye
EOF
  log "Uploaded to ${host}"
}

install_pkg_console() {
  local host="$1"
  local pass="$2"

  log "Installing package on ${host} via pfSense console menu..."

  expect - <<'EOF' "$host" "$pass" "$PKG_FILE"
set timeout 180
log_user 1

set host [lindex $argv 0]
set pass [lindex $argv 1]
set pkg  [lindex $argv 2]

spawn ssh -tt -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@$host

expect {
  -nocase -re {password for .*:} { send -- "$pass\r" }
  -nocase -re {password:} { send -- "$pass\r" }
  timeout { puts "ERROR: No password prompt"; exit 1 }
  eof     { puts "ERROR: SSH exited early"; exit 1 }
}

# Wait for pfSense menu
expect {
  -nocase -re {enter an option:} {}
  timeout { puts "ERROR: Did not reach pfSense menu"; exit 1 }
  eof     { puts "ERROR: SSH closed before menu"; exit 1 }
}

# 8 = Shell
send "8\r"
after 400

send -- "echo __IN_SHELL__\r"
expect {
  -re {__IN_SHELL__} {}
  timeout { puts "ERROR: Did not confirm shell"; exit 1 }
  eof     { puts "ERROR: SSH closed entering shell"; exit 1 }
}

send -- "pkg-static add /root/$pkg; echo __ADD_PKG_DONE__\r"
expect {
  -re {__ADD_PKG_DONE__} {}
  timeout { puts "ERROR: pkg-static add did not complete"; exit 1 }
  eof     { puts "ERROR: SSH closed while installing package"; exit 1 }
}

send -- "exit\r"
expect {
  -nocase -re {enter an option:} {}
  timeout { puts "ERROR: Did not return to menu"; exit 1 }
  eof     { puts "ERROR: SSH closed before returning to menu"; exit 1 }
}

send -- "0\r"
expect eof
EOF

  log "Install complete on ${host}"
}

upload_pkg "$BRANCH_FW" "$BRANCHPASS"
install_pkg_console "$BRANCH_FW" "$BRANCHPASS"

upload_pkg "$APP_FW" "$APPPASS"
install_pkg_console "$APP_FW" "$APPPASS"

log "Done: REST API pkg uploaded + installed on both firewalls."

# -------------------------------------------------------------------
# 3) Optional: create first-time backups
# -------------------------------------------------------------------
read -rp "Create first time backups? [y/N]: " CREATE_BACKUPS
CREATE_BACKUPS="${CREATE_BACKUPS:-N}"

if [[ "$CREATE_BACKUPS" =~ ^([yY]|[yY][eE][sS])$ ]]; then
  log "Creating golden backups on Cisco devices (unix:golden-backup.cfg)..."

  telnet_backup() {
    local host="$1"
    local user="${2:-}"
    local pass="${3:-}"
    local enable="${4:-}"

    log "Telnet -> ${host}"

    expect - <<'EOF' "$host" "$user" "$pass" "$enable"
set timeout 40
log_user 1

set host [lindex $argv 0]
set user [lindex $argv 1]
set pass [lindex $argv 2]
set en   [lindex $argv 3]

set TELNET_ESC "\035"

spawn telnet $host

expect {
  -nocase -re {username:} { send -- "$user\r"; exp_continue }
  -nocase -re {password:} { send -- "$pass\r"; exp_continue }
  -re {>} {}
  -re {#} {}
  timeout { puts "ERROR: did not reach prompt on $host"; exit 1 }
}

send -- "\r"
expect {
  -re {#} {}
  -re {>} {
    send -- "enable\r"
    expect {
      -nocase -re {password:} {
        if {$en eq ""} { puts "ERROR: enable password required but not provided"; exit 1 }
        send -- "$en\r"
      }
      -re {#} {}
      timeout { puts "ERROR: could not enter enable on $host"; exit 1 }
    }
  }
}

send -- "terminal length 0\r"
expect -re {#}

send -- "copy running-config unix:golden-backup.cfg\r"

expect {
  -nocase -re {destination filename.*[:?]\s*$} { send -- "\r"; exp_continue }
  -nocase -re {destination filename.*\]\s*[:?]\s*$} { send -- "\r"; exp_continue }
  -nocase -re {destination filename.*\]\s*$} { send -- "\r"; exp_continue }
  -nocase -re {overwrite.*\[confirm\]}  { send -- "\r"; exp_continue }
  -nocase -re {bytes copied|copy complete|copied in|OK} { exp_continue }
  -re {#} {}
  timeout { puts "WARN: did not see prompt return on $host"; }
}

send -- "exit\r"
expect {
  -re {Connection closed|closed by foreign host} {}
  -re {telnet>} {}
  timeout {}
}

send -- "$TELNET_ESC"
send -- "quit\r"
expect eof
EOF
  }

  # shellcheck disable=SC2154
  telnet_backup "${SWITCH1_MGMT_IP:-}"    "${SWITCH1_USERNAME:-}"    "${SWITCH1_PASSWORD:-}"    "${SWITCH1_ENABLE:-}"
  telnet_backup "${SP_ROUTER1_NB_IP:-}"   "${SP_ROUTER1_USERNAME:-}" "${SP_ROUTER1_PASSWORD:-}" "${SP_ROUTER1_ENABLE:-}"
  telnet_backup "${SP_ROUTER2_NB_IP:-}"   "${SP_ROUTER2_USERNAME:-}" "${SP_ROUTER2_PASSWORD:-}" "${SP_ROUTER2_ENABLE:-}"

  log "Saving Firewall Configuration..."
  mkdir -p "${BASE_HOME}/uproot/opt/pfsense"

  sshpass -p "${BRANCH_FW_PASSWORD}" scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
    root@"${BRANCH_FW_MGMT_IP}":/conf/config.xml \
    "${BASE_HOME}/uproot/opt/pfsense/lab1-branch_fw_default_config.xml"

  sshpass -p "${APP_FW_PASSWORD}" scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
    root@"${APP_FW_MGMT_IP}":/conf/config.xml \
    "${BASE_HOME}/uproot/opt/pfsense/lab1-app_fw_default_config.xml"

  log "First-time backups complete."
else
  log "Skipping first-time backups."
fi

# -------------------------------------------------------------------
# 4) Python deps + install /usr/local/bin/uproot launcher
# -------------------------------------------------------------------
log "Installing Python requirements..."
python3 -m pip install -r "${BASE_HOME}/uproot/labs/lab1/requirements.txt" --break-system-packages --ignore-installed

log "Installing /usr/local/bin/uproot launcher..."
cat <<'EOF' >/usr/local/bin/uproot
#!/usr/bin/env bash
set -euo pipefail

BASE="/home/user/uproot/labs"

usage() {
  echo "Usage: uproot <lab> [args]"
  echo "Example: uproot lab1 -v"
  exit 2
}

[[ $# -ge 1 ]] || usage

LAB="$1"; shift
LABDIR="${BASE}/${LAB}"
PY="${LABDIR}/break_things.py"

[[ -d "$LABDIR" ]] || { echo "Unknown lab: $LAB (missing $LABDIR)" >&2; exit 2; }
[[ -f "$PY" ]]     || { echo "Missing: $PY" >&2; exit 2; }

exec python3 "$PY" "$@"
EOF

chmod +x /usr/local/bin/uproot

log "Setup complete."
