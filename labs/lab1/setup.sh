#!/usr/bin/env bash
log() { echo "[$(date +'%F %T')] $*" >&2; }

log "Checking Updates & Installing Dependencies...."

apt update
apt-get install -y net-tools sshpass python3 python3-pip expect

mv uproot-labs-* uproot
cp uproot/labs/lab1/.env.golden uproot/labs/lab1/.env

log "Resetting Network Params..."

set -euo pipefail

# --------- Add Routes To 2nd Intf ----------
IFACE="ens4"

ROUTES_TO_ADD=(
  "1.1.1.0/30"
  "2.2.2.0/30"
  "3.3.3.0/30"
  "192.168.0.0/16"
)

ENS4_SNIPPET="/etc/netplan/99-${IFACE}-dhcp.yaml"

TIMEOUT_SECONDS=45

require_root() {
  if [[ "${EUID}" -ne 0 ]]; then
    echo "Please run as root: sudo $0"
    exit 1
  fi
}


write_ens4_snippet() {
  log "Writing netplan snippet: ${ENS4_SNIPPET}"
  if [[ -f "${ENS4_SNIPPET}" ]]; then
    rm -f /etc/netplan/99-ens4-dhcp.yaml.*
    cp -a "${ENS4_SNIPPET}" "${ENS4_SNIPPET}.bak.$(date +%s)"
    log "Backed up existing snippet."
  fi

  cat > "${ENS4_SNIPPET}" <<EOF
# Generated by configure_ens4_and_routes.sh
network:
  version: 2
  ethernets:
    ${IFACE}:
      dhcp4: true
      dhcp4-overrides:
        route-metric: 200
EOF
}

netplan_apply() {
  log "Running: netplan apply"
  netplan apply
}

get_gateway() {
  local iface="$1"
  ip route show default dev "$iface" 2>/dev/null | awk '$1=="default"{print $3; exit}'
}

wait_for_gateway() {
  local iface="$1"
  local t=0
  log "Waiting up to ${TIMEOUT_SECONDS}s for DHCP gateway on ${iface}..."

  while (( t < TIMEOUT_SECONDS )); do
    local gw
    gw="$(get_gateway "$iface" || true)"
    if [[ -n "$gw" ]]; then
      echo "$gw"
      return 0
    fi
    sleep 1
    ((t++))
  done

  log "❌ Timed out waiting for gateway on ${iface}"
  ip link show "$iface" || true
  ip -4 addr show dev "$iface" || true
  ip route show dev "$iface" || true
  ip route show default || true
  return 1
}

add_routes_once() {
  local iface="$1"

  if ip link show "$iface" | grep -q "state DOWN"; then
    log "Interface ${iface} is DOWN; bringing it UP"
    ip link set "$iface" up
  fi

  local gw
  gw="$(wait_for_gateway "$iface")" || exit 1

  log "Using gateway ${gw} on ${iface} to install routes"
  for net in "${ROUTES_TO_ADD[@]}"; do
    log "  ip route replace ${net} via ${gw} dev ${iface}"
    ip route replace "${net}" via "${gw}" dev "${iface}"
  done
}

main() {
  require_root
 
  log "Step 1) Updating netplan to include ${IFACE} (DHCP)"
  write_ens4_snippet

  log "Step 2) Apply netplan"
  netplan_apply

  log "Step 3) Add routes out ${IFACE}"
  add_routes_once "${IFACE}"

#  log "Step 4) Apply netplan again (per your requirement)"
#  netplan_apply

#  log "Step 5) Re-add routes (netplan apply may flush routes)"
#  add_routes_once "${IFACE}"

  log "✅ Done. Current routes:"
  ip route | sed 's/^/  /'
}

main "$@"

### ------ Enable Rest API in pfSense -----

log "Setting up REST API package on pfSense Firewalls (Branch + App)"

ENV_FILE="/home/user/uproot/labs/lab1/.env"


env_upsert() {
	local key="$1"
	local value="$2"

	local escaped
	escaped="$(printf '%s' "$value" | sed 's/\\/\\\\/g; s/"/\\"/g')"
	
	if grep -qE "^${key}=" "$ENV_FILE"; then
		sed -i "s|^${key}=.*|${key}=\"${escaped}\"|g" "$ENV_FILE"
	else
		printf '\n%s="%s"\n' "$key" "$escaped" >> "$ENV_FILE"
	fi
}

USER="root"
PKG_FILE="pfSense-2.8.1-pkg-RESTAPI.pkg"
PKG_URL="https://github.com/jaredhendrickson13/pfsense-api/releases/latest/download/${PKG_FILE}"

# --- Prompts ---

read -rp "Branch pfSense MGMT IP [1.1.1.2]: " BRANCH_FW
BRANCH_FW="${BRANCH_FW:-1.1.1.2}"
read -srp "Branch pfSense password: " BRANCHPASS
echo

read -rp "App pfSense MGMT IP [3.3.3.2]: " APP_FW
APP_FW="${APP_FW:-3.3.3.2}"
read -srp "App pfSense password: " APPPASS
echo

env_upsert "BRANCH_FW_MGMT_IP" "$BRANCH_FW"
env_upsert "BRANCH_FW_PASSWORD" "$BRANCHPASS"
env_upsert "APP_FW_MGMT_IP" "$APP_FW"
env_upsert "APP_FW_PASSWORD" "$APPPASS"


if [[ -f "$ENV_FILE" ]]; then
	set -a
	source "$ENV_FILE"
	set +a
else
	log "$ENV_FILE not found"
	exit 1
fi

# --- Download REST API pkg from GitHub ---<< NO LONGER NEEDED, pkg is included locally in /opt/pfsense/
#log "Downloading REST API package: ${PKG_FILE}"
#rm -f "${PKG_FILE}"
#wget -q --show-progress -O "${PKG_FILE}" "${PKG_URL}"

# --- Upload locally to each FW ---
upload_pkg() {
  local host="$1"
  local pass="$2"

  log "Uploading ${PKG_FILE} to ${host}..."
  sshpass -p "$pass" sftp \
    -o StrictHostKeyChecking=no \
    -o UserKnownHostsFile=/dev/null \
    "${USER}@${host}" <<EOF
put /home/user/uproot/opt/pfsense/${PKG_FILE} /root/${PKG_FILE}
bye
EOF
  log "Uploaded to ${host}"
}

# --- Install from local FW (no int access) (console menu -> shell -> pkg-static add -> logout) ---
install_pkg_console() {
  local host="$1"
  local pass="$2"

  log "Installing package on ${host} via console menu..."

  expect - <<'EOF' "$host" "$USER" "$pass" "$PKG_FILE"
set timeout 120
log_user 1

set host [lindex $argv 0]
set user [lindex $argv 1]
set pass [lindex $argv 2]
set pkg  [lindex $argv 3]

spawn ssh -tt -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null $user@$host

# Login
expect {
  -nocase -re {password for .*:} { send -- "$pass\r" }
  -nocase -re {password:}        { send -- "$pass\r" }
  timeout { puts "ERROR: No password prompt matched"; exit 1 }
  eof     { puts "ERROR: SSH exited early"; exit 1 }
}

# Wait for pfSense menu
expect {
  -nocase -re {enter an option:} {}
  timeout { puts "ERROR: Did not reach pfSense menu"; exit 1 }
  eof     { puts "ERROR: SSH closed before menu"; exit 1 }
}

# 8 = Shell
send "8\r"
after 500

# Confirm we're in a shell (avoid prompt-matching issues)
send -- "echo __IN_SHELL__\r"
expect {
  -re {__IN_SHELL__} {}
  timeout { puts "ERROR: Did not confirm shell"; exit 1 }
  eof     { puts "ERROR: SSH closed entering shell"; exit 1 }
}

# Install pkg + sentinel
send -- "pkg-static add /root/$pkg; echo __ADD_PKG_DONE__\r"
expect {
  -re {__ADD_PKG_DONE__} {}
  timeout { puts "ERROR: pkg-static add did not complete"; exit 1 }
  eof     { puts "ERROR: SSH closed while installing package"; exit 1 }
}

# Exit shell back to menu
send -- "exit\r"
expect {
  -nocase -re {enter an option:} {}
  timeout { puts "ERROR: Did not return to menu"; exit 1 }
  eof     { puts "ERROR: SSH closed before returning to menu"; exit 1 }
}

# 0 = Logout
send -- "0\r"
expect eof
EOF

  log "Install complete on ${host}"
}

# --- Run both func ---
upload_pkg "$BRANCH_FW" "$BRANCHPASS"
install_pkg_console "$BRANCH_FW" "$BRANCHPASS"

upload_pkg "$APP_FW" "$APPPASS"
install_pkg_console "$APP_FW" "$APPPASS"

log "✅ Done: REST API pkg uploaded + installed on both firewalls."



# ---------------- Create first-time backups ----------------
read -rp "Create first time backups? [y/N]: " CREATE_BACKUPS
CREATE_BACKUPS="${CREATE_BACKUPS:-N}"

if [[ "$CREATE_BACKUPS" =~ ^([yY]|[yY][eE][sS])$ ]]; then
  log "Creating golden backups on Cisco devices (unix:golden-backup.cfg)..."

  telnet_backup() {
    local host="$1"
    local user="${2:-}"
    local pass="${3:-}"
    local enable="${4:-}"

    log "  Telnet -> ${host}"

    expect - <<'EOF' "$host" "$user" "$pass" "$enable"
set timeout 40
log_user 1

set host [lindex $argv 0]
set user [lindex $argv 1]
set pass [lindex $argv 2]
set en   [lindex $argv 3]

# Ctrl-] for telnet escape
set TELNET_ESC "\035"

spawn telnet $host

# Login flow (some devices ask, some don't)
expect {
  -nocase -re {username:} { send -- "$user\r"; exp_continue }
  -nocase -re {password:} { send -- "$pass\r"; exp_continue }
  -re {>} {}
  -re {#} {}
  timeout { puts "ERROR: did not reach prompt on $host"; exit 1 }
}

# Ensure enable
send -- "\r"
expect {
  -re {#} {}
  -re {>} {
    send -- "enable\r"
    expect {
      -nocase -re {password:} {
        if {$en eq ""} { puts "ERROR: enable password required but not provided"; exit 1 }
        send -- "$en\r"
      }
      -re {#} {}
      timeout { puts "ERROR: could not enter enable on $host"; exit 1 }
    }
  }
}

# Make output non-paged
send -- "terminal length 0\r"
expect -re {#}

# Run copy
send -- "copy running-config unix:golden-backup.cfg\r"

# Handle destination prompt and any overwrite confirm, then wait back at prompt
expect {
  -nocase -re {destination filename.*[:?]\s*$} { send -- "\r"; exp_continue }
  -nocase -re {destination filename.*\]\s*[:?]\s*$} { send -- "\r"; exp_continue }
  -nocase -re {destination filename.*\]\s*$} { send -- "\r"; exp_continue }
  -nocase -re {overwrite.*\[confirm\]}  { send -- "\r"; exp_continue }
  -nocase -re {bytes copied|copy complete|copied in|OK} { exp_continue }
  -re {#} {}
  timeout { puts "WARN: did not see prompt return on $host (copy prompt may differ)"; }
}

# Try to close the IOS session
send -- "exit\r"
expect {
  -re {Connection closed|closed by foreign host} {}
  -re {telnet>} {}
  timeout {}
}

# Force-exit telnet client if still open
send -- "$TELNET_ESC"
send -- "quit\r"
expect eof
EOF
  }



  # You must have these in .env already for the lab
  # SWITCH1_MGMT_IP, SP_ROUTER1_MGMT_IP, SP_ROUTER2_MGMT_IP
  telnet_backup "$SWITCH1_MGMT_IP"   "${SWITCH1_USERNAME:-}"   "${SWITCH1_PASSWORD:-}"   "${SWITCH1_ENABLE:-}"
  telnet_backup "$SP_ROUTER1_NB_IP" "${SP_ROUTER1_USERNAME:-}" "${SP_ROUTER1_PASSWORD:-}" "${SP_ROUTER1_ENABLE:-}"
  telnet_backup "$SP_ROUTER2_NB_IP" "${SP_ROUTER2_USERNAME:-}" "${SP_ROUTER2_PASSWORD:-}" "${SP_ROUTER2_ENABLE:-}"

  log "Saving Firewall Configuration..."
  mkdir -p /home/user/uproot/opt/pfsense

  sshpass -p "$BRANCH_FW_PASSWORD" scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
    root@"$BRANCH_FW_MGMT_IP":/conf/config.xml \
    /home/user/uproot/opt/pfsense/lab1-branch_fw_default_config.xml

  sshpass -p "$APP_FW_PASSWORD" scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
    root@"$APP_FW_MGMT_IP":/conf/config.xml \
    /home/user/uproot/opt/pfsense/lab1-app_fw_default_config.xml

  log "✅ First-time backups complete."
else
  log "Skipping first-time backups."
fi


python3 -m pip install -r /home/user/uproot/labs/lab1/requirements.txt --break-system-packages --ignore-installed

cat <<'EOF' >/usr/local/bin/uproot
#!/usr/bin/env bash
set -euo pipefail

BASE="/home/user/uproot/labs"

usage() {
  echo "Usage: uproot <lab> [args]"
  echo "Example: uproot lab1 -v"
  exit 2
}

[[ $# -ge 1 ]] || usage

LAB="$1"; shift
LABDIR="${BASE}/${LAB}"
PY="${LABDIR}/break_things.py"

[[ -d "$LABDIR" ]] || { echo "Unknown lab: $LAB (missing $LABDIR)"; exit 2; }
[[ -f "$PY" ]]     || { echo "Missing: $PY"; exit 2; }

exec python3 "$PY" "$@"
EOF

chmod +x /usr/local/bin/uproot
